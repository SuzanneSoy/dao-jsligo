#import "./constants.jsligo" "Constants"
#import "./errors.jsligo" "Errors"
#import "./lambda.jsligo" "Lambda"
#import "./outcome.jsligo" "Outcome"
#import "./proposal.jsligo" "Proposal"
#import "./storage.jsligo" "Storage"
#import "./vote.jsligo" "Vote"
#import "./token.jsligo" "Token"
#import "./vault.jsligo" "Vault"
#import "./timelock.jsligo" "Timelock"

export type parameter =
    // @layout:comb
    | ["Propose", Proposal.makeParams]
    | ["Cancel", option<nat>]
    | ["Lock", Vault.amount_]
    | ["Release", Vault.amount_]
    | ["Execute", Outcome.executeParams]
    | ["Vote", Vote.choice]
    | ["EndVote"]
;

export type storage = Storage.t;
type result = [list<operation>, storage];

const execute = (outcomeKey: nat, packed: bytes, s: storage) : result => {
    const proposal = match(Big_map.find_opt(outcomeKey, s.outcomes)) {
        when(None): failwith(Errors.outcomeNotFound);
        when(Some(outcome)): Outcome.getExecutableProposal(outcome)
    };

    Timelock._checkUnlocked(proposal.timelock);
    const lambda_ : Lambda.t = Lambda.unpack(proposal.hash, packed);

    return match(lambda_) {
        when(OperationList(f)): [
            f(),
            Storage.updateOutcome(outcomeKey, [proposal, Executed()], s)
        ];
        when(ParameterChange(f)): [
            Constants.noOperation,
            Storage.updateOutcome(
                outcomeKey,
                [proposal, Executed()],
                Storage.updateConfig(f,s)
            )
        ]
    };
};

const propose = (p: Proposal.makeParams, s: storage) : result =>
    match(s.proposal) {
        when(Some(_proposal)): failwith(Errors.proposalAlreadyExists);
        when(None): [
            list([Token.transfer(
                [s.governanceToken,
                Tezos.get_sender(),
                Tezos.get_self_address(),
                s.config.depositAmount]
            )]), Storage.createProposal(
                Proposal.make(p, s.config.startDelay, s.config.votingPeriod),
                s)
        ]
    };

const cancel = (outcomeKeyOpt: option<nat>, s: storage) : result =>
   [
       list([Token.transfer(
            [s.governanceToken,
             Tezos.get_self_address(),
             s.config.burnAddress,
             s.config.depositAmount])
       ]),
       match(outcomeKeyOpt) {
            when(None):
                match(s.proposal) {
                    when(None): failwith(Errors.nothingToCancel);
                    when(Some(proposal)): do {
                        Proposal._checkNotVotingPeriod(proposal);
                        assert_with_error(
                            proposal.creator == Tezos.get_sender(),
                            Errors.notCreator
                        );

                        return Storage.addOutcome([proposal, Canceled()], s);
                    }
                };
            when(Some(outcomeKey)):
                match(Big_map.find_opt(outcomeKey, s.outcomes)) {
                    when(None): failwith(Errors.outcomeNotFound);
                    when(Some(outcome)): do {
                        const [p, state] = outcome;
                        assert_with_error(
                            p.creator == Tezos.get_sender(),
                            Errors.notCreator
                        );
                        assert_with_error(
                            state != (Executed() as Outcome.state),
                            Errors.alreadyExecuted
                        );
                        Timelock._checkLocked(p.timelock);

                        return Storage.updateOutcome(outcomeKey, [p, Canceled()], s)
                    }
                }
        }
   ];

const lock = (amount_: nat, s: storage) : result => {
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUser([s.vault, Tezos.get_sender()]);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_sender(),
            Tezos.get_self_address(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            currentAmount + amount_]), s)
    ];
};

const release = (amount_: nat, s: storage) : result => {
    Proposal._checkNoVoteOngoing(s.proposal);
    const currentAmount = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
    assert_with_error( (currentAmount >= amount_), Errors.notEnoughBalance);

    return [
        list([Token.transfer(
            [s.governanceToken,
            Tezos.get_self_address(),
            Tezos.get_sender(), amount_])]),
        Storage.updateVault(Vault.updateForUser(
            [s.vault,
            Tezos.get_sender(),
            abs(currentAmount - amount_)]), s)
    ];
};

const vote = (choice: bool, s: storage) : storage =>
    match(s.proposal) {
        when(None): failwith(Errors.noProposal);
        when(Some(proposal)): do {
            Proposal._checkIsVotingPeriod(proposal);
            const amount_ = Vault.getForUserExn([s.vault, Tezos.get_sender()]);
            return Storage.updateVotes(proposal, [choice, amount_], s);
        }
    };

const endVote = (s: storage) : result =>
    match(s.proposal) {
        when(None): failwith(Errors.noProposal);
        when(Some(proposal)): do {
            Proposal._checkVotingPeriodEnded(proposal);
            const totalSupply = match(Token.getTotalSupply(s.governanceToken)) {
                when(None): failwith(Errors.fa2TotalSupplyNotFound);
                when(Some(n)): n
            };
            const outcome = Outcome.make(
                    proposal,
                    totalSupply,
                    s.config.refundThreshold,
                    s.config.quorumThreshold,
                    s.config.superMajority
                );
            const [_, state] = outcome;

            let transferToAddr = proposal.creator;
            if (Rejected_(WithoutRefund()) == state) {
                transferToAddr = s.config.burnAddress;
            }
            return [
                list([Token.transfer(
                    [s.governanceToken,
                    Tezos.get_self_address(),
                    transferToAddr,
                    s.config.depositAmount])])
                , Storage.addOutcome(outcome, s)
            ];
        }
    };

@entry
const main = (action: parameter, store: storage) : result => {
    assert_with_error(Tezos.get_amount() == (0 as tez), Errors.notZeroAmount);
    return match(action) {
        when(Propose(proposalMakeParams)): propose(proposalMakeParams, store);
        when(Cancel(nOpt)): cancel(nOpt, store);
        when(Lock(n)): lock(n, store);
        when(Release(n)): release(n, store);
        when(Execute(outcomeExecuteParam)): execute(outcomeExecuteParam.outcomeKey, outcomeExecuteParam.packed, store);
        when(Vote(voteChoice)): [Constants.noOperation, vote(voteChoice, store)];
        when(EndVote): endVote(store);
    };
};
